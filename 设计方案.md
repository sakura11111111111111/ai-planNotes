-

### **《智能复习笔记》V1.0 产品设计文档 - 目录**
**第一章：项目概述**
1.1. 项目背景与目标
1.2. 核心用户画像
1.3. MVP范围定义
1.4. 技术栈总览
**第二章：数据库设计**
2.1. 设计原则
2.2. ER图 (实体关系图)
2.3. 表结构详解
    2.3.1. 用户表 (users)
    2.3.2. 分类表 (categories)
    2.3.3. 笔记表 (notes)
    2.3.4. AI总结表 (ai_summaries)
    2.3.5. 复习记录表 (review_records)
2.4. 核心业务查询SQL示例
**第三章：API接口文档**
3.1. 设计规范
3.2. 用户认证模块
    3.2.1. 用户注册
    3.2.2. 用户登录
3.3. 笔记管理模块
    3.3.1. 创建笔记
    3.3.2. 获取笔记详情
    3.3.3. 修改笔记
    3.3.4. 删除笔记
    3.3.5. 获取分类下的笔记列表
3.4. 复习任务模块
    3.4.1. **获取今日任务列表** (已定义)
    3.4.2. **提交复习结果** (待定义)
3.5. AI功能模块
    3.5.1. 生成AI总结
3.6. 分类管理模块
    3.6.1. 创建分类
    3.6.2. 获取所有分类
    3.6.3. 修改分类名
    3.6.4. 删除分类
**第四章：核心业务逻辑设计**
4.1. 复习算法（艾宾浩斯曲线）实现逻辑
4.2. 监督机制流程与防作弊策略
4.3. AI总结服务调用流程
**第五章：前端页面与交互流程**
5.1. 核心页面流程图
5.2. 今日任务页面
5.3. 笔记编辑与监督页面
5.4. 任务完成状态页面
---
### 下一步主动引导
**请审查上面的目录。**
**你觉得这个框架足够完整吗？有没有哪个模块你觉得需要补充，或者哪个模块在V1.0阶段可以暂时去掉？**
**一旦你确认了这个“骨架”，我们就可以立刻开始填充第一章的内容。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在开始填充第一章。
以下是《智能复习笔记》V1.0 产品设计文档的第一章内容。你可以直接复制，保存到你的文档中。
---
### **第一章：项目概述**
#### 1.1. 项目背景与目标
**背景：**
在信息爆炸的时代，学习者（尤其是学生和备考人群）每天都需要记录和处理大量知识。然而，传统的笔记应用仅解决了“记录”的问题，却忽视了“巩固”这一核心环节。根据艾宾浩斯遗忘曲线，知识在学习后会迅速遗忘，若无有效的复习机制，学习效率将大打折扣。市面上的部分复习工具（如Anki）虽遵循记忆曲线，但其“卡片化”的模式不适合承载长篇、有上下文的笔记内容，制作成本高昂。
**目标：**
本项目旨在开发一款以“长篇笔记”为核心载体的智能复习工具。它将无缝融合“艾宾浩斯遗忘曲线”算法与“AI大模型总结”能力，实现从“记录”到“掌握”的学习闭环。我们的目标是帮助用户：
1.  **降低复习门槛：** 无需制作卡片，直接复习原始笔记。
2.  **提升复习效率：** 通过AI总结快速回顾要点，通过科学算法安排复习计划。
3.  **增强学习自律：** 通过监督机制，对抗分心，保证复习质量。
#### 1.2. 核心用户画像
*   **姓名：** 小李
*   **身份：** 正在备战研究生考试或职业资格考试的大学生/职场新人。
*   **行为特征：**
    *   每天花费大量时间阅读教材、观看网课，并习惯用电子笔记记录知识点。
    *   深知复习的重要性，但缺乏系统性的复习计划，常常“学了就忘”。
    *   尝试过类似Anki的工具，但将一整章高数或政治内容制作成知识卡片的过程过于繁琐，最终放弃。
    *   在自习或复习时，手机是最大的干扰源，难以长时间保持专注。
*   **核心需求：**
    *   需要一个工具能自动告诉他“今天该复习什么”。
    *   希望能直接在原始笔记上进行复习，而不是碎片化的卡片。
    *   需要一种机制来强制自己专注学习。
#### 1.3. MVP范围定义
为确保快速验证核心价值，V1.0版本将聚焦于以下核心功能，并明确排除非必要功能。
**V1.0 核心功能（必须实现）：**
*   **用户系统：** 支持邮箱注册与密码登录。
*   **笔记管理：** 创建、编辑、删除笔记；创建、管理笔记分类。
*   **AI总结：** 对笔记内容一键生成核心要点总结。
*   **复习计划：** 基于艾宾浩斯曲线，为每条新笔记自动生成后续复习计划。
*   **任务中心：** 提供清晰的“今日任务”列表，展示所有待复习的笔记。
*   **监督机制：** 在复习页面，提供可配置的强制停留时间，防止用户“秒滑”。
*   **结果反馈：** 支持用户提交“已记住/模糊/忘记”三种复习结果，并据此更新后续复习计划。
**V1.0 明确不包含的功能（后续版本考虑）：**
*   **社交功能：** 笔记分享、好友排名、学习小组等。
*   **深度数据分析：** 复习时长统计、正确率图表、知识掌握度雷达图等。
*   **多端实时同步：** V1.0优先保障安卓端体验，网页版作为辅助，不追求实时同步。
*   **离线模式：** 所有功能均需联网使用。
*   **数据导入/导出：** 不支持从其他笔记软件导入，或导出为Markdown等格式。
*   **高级自定义：** 如自定义复习算法、自定义AI总结Prompt等。
#### 1.4. 技术栈总览
本项目采用前后端分离的架构，技术选型兼顾开发效率、性能与未来扩展性。
*   **后端：**
    *   **框架：** Java Spring Boot 3.x
    *   **数据库：** MySQL 8.0
    *   **数据访问：** Spring Data JPA
    *   **安全认证：** Spring Security 6 + JWT
    *   **容器化：** Docker
*   **前端：**
    *   **框架：** Flutter
    *   **目标平台：** Android (主), Web (辅)
*   **AI服务：**
    *   **方案：** 调用第三方云端大模型API（如OpenAI GPT-4、文心一言等）
*   **部署：**
    *   **后端：** 部署于云服务器（如阿里云ECS）
---
### 下一步主动引导
**第一章内容已完成。请审查，如果没问题，我们就可以继续填充第二章：数据库设计。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在来填充第二章：数据库设计。
这一章是整个系统的数据基石，也是你将来审查AI生成代码时最重要的依据。
---
### **第二章：数据库设计**
#### 2.1. 设计原则
本数据库设计遵循以下核心原则，以确保数据的一致性、完整性和可扩展性：
1.  **规范化：** 遵循第三范式（3NF），消除数据冗余，确保数据依赖的合理性。例如，将用户信息和笔记信息分离，将AI总结和笔记正文分离。
2.  **关系明确：** 使用外键（FOREIGN KEY）明确表与表之间的引用关系，保证数据的引用完整性。
3.  **主键稳定：** 使用无业务含义的自增长长整型（BIGINT）作为主键，避免因业务变化导致主键变更。
4.  **预留扩展：** 在关键表中预留字段（如`model_used`），为未来功能扩展（如支持多种AI模型、记录成本等）提供空间。
5.  **索引优化：** 在高频查询字段（如`user_id`, `scheduled_for`）上建立索引，提升查询性能。
#### 2.2. ER图 (实体关系图)
以下是本系统核心实体及其关系的简化表示：
```
+-----------+       +----------------+       +-----------------+
|   users   |       |    categories  |       |   review_records|
|-----------|       |----------------|       |-----------------|
| id (PK)   |1--N   | id (PK)        |       | id (PK)         |
| username  |-------| user_id (FK)   |       | note_id (FK)    |
| ...       |       | name           |       | stage_number    |
+-----------+       | ...            |       | scheduled_for   |
                    +----------------+       | reviewed_at     |
                            |               | result          |
                            |               +-----------------+
                            |
                            |1--N
                    +----------------+       +-----------------+
                    |     notes      |1-----1|  ai_summaries   |
                    |----------------|       |-----------------|
                    | id (PK)        |       | id (PK)         |
                    | user_id (FK)   |       | note_id (FK, UQ)|
                    | category_id(FK)|       | summary_text    |
                    | title          |       | model_used      |
                    | content        |       | created_at      |
                    | is_supervised  |       +-----------------+
                    | ...            |
                    +----------------+
```
**关系说明：**
*   `users` 和 `categories` 是一对多关系（一个用户有多个分类）。
*   `users` 和 `notes` 是一对多关系（一个用户有多篇笔记）。
*   `categories` 和 `notes` 是一对多关系（一个分类下有多篇笔记）。
*   `notes` 和 `ai_summaries` 是一对一关系（一篇笔记对应一个AI总结）。
*   `notes` 和 `review_records` 是一对多关系（一篇笔记对应多条复习记录）。
#### 2.3. 表结构详解
**2.3.1. 用户表 (users)**
| 字段名                                 | 数据类型                                 | 约束/索引                                             | 备注                                 |
| -------------------------------------- | ---------------------------------------- | ----------------------------------------------------- | ------------------------------------ |
| id                                     | BIGINT                                   | PRIMARY KEY, AUTO_INCREMENT                           | 用户唯一ID                           |
| username                               | VARCHAR(50)                              | UNIQUE, NOT NULL, INDEX                               | 用户名，用于登录                     |
| password_hash                          | VARCHAR(255)                             | NOT NULL                                              | 加密后的密码（如使用BCrypt）         |
| email                                  | VARCHAR(100)                             | UNIQUE, NOT NULL, INDEX                               | 邮箱，可用于登录或找回密码           |
| created_at                             | TIMESTAMP                                | DEFAULT CURRENT_TIMESTAMP                             | 账号创建时间                         |
| updated_at                             | TIMESTAMP                                | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 最后更新时间                         |
| **2.3.2. 分类表 (categories)**         |                                          |                                                       |                                      |
| 字段名                                 | 数据类型                                 | 约束/索引                                             | 备注                                 |
| ---                                    | ---                                      | ---                                                   | ---                                  |
| id                                     | BIGINT                                   | PRIMARY KEY, AUTO_INCREMENT                           | 分类唯一ID                           |
| user_id                                | BIGINT                                   | NOT NULL, FOREIGN KEY -> `users.id`                   | 所属用户ID                           |
| name                                   | VARCHAR(100)                             | NOT NULL                                              | 分类名称（如“考研数学”、“工作笔记”） |
| created_at                             | TIMESTAMP                                | DEFAULT CURRENT_TIMESTAMP                             | 创建时间                             |
| **2.3.3. 笔记表 (notes)**              |                                          |                                                       |                                      |
| 字段名                                 | 数据类型                                 | 约束/索引                                             | 备注                                 |
| ---                                    | ---                                      | ---                                                   | ---                                  |
| id                                     | BIGINT                                   | PRIMARY KEY, AUTO_INCREMENT                           | 笔记唯一ID                           |
| user_id                                | BIGINT                                   | NOT NULL, FOREIGN KEY -> `users.id`                   | 所属用户ID                           |
| category_id                            | BIGINT                                   | FOREIGN KEY -> `categories.id`                        | 所属分类ID，可为NULL（表示未分类）   |
| title                                  | VARCHAR(255)                             | NOT NULL                                              | 笔记标题                             |
| content                                | TEXT                                     | NOT NULL                                              | 笔记原文内容                         |
| is_supervised                          | BOOLEAN                                  | DEFAULT FALSE                                         | 是否开启监督机制                     |
| supervision_duration_seconds           | INT                                      | DEFAULT 10                                            | 监督时长（秒），默认10秒             |
| created_at                             | TIMESTAMP                                | DEFAULT CURRENT_TIMESTAMP                             | 创建时间                             |
| updated_at                             | TIMESTAMP                                | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 最后更新时间                         |
| **2.3.4. AI总结表 (ai_summaries)**     |                                          |                                                       |                                      |
| 字段名                                 | 数据类型                                 | 约束/索引                                             | 备注                                 |
| ---                                    | ---                                      | ---                                                   | ---                                  |
| id                                     | BIGINT                                   | PRIMARY KEY, AUTO_INCREMENT                           | 总结唯一ID                           |
| note_id                                | BIGINT                                   | UNIQUE, NOT NULL, FOREIGN KEY -> `notes.id`           | 关联的笔记ID（一对一关系）           |
| summary_text                           | TEXT                                     | NOT NULL                                              | AI生成的总结内容                     |
| model_used                             | VARCHAR(50)                              | NULL                                                  | 使用的AI模型（如 'gpt-4-turbo'）     |
| created_at                             | TIMESTAMP                                | DEFAULT CURRENT_TIMESTAMP                             | 生成时间                             |
| **2.3.5. 复习记录表 (review_records)** |                                          |                                                       |                                      |
| 字段名                                 | 数据类型                                 | 约束/索引                                             | 备注                                 |
| ---                                    | ---                                      | ---                                                   | ---                                  |
| id                                     | BIGINT                                   | PRIMARY KEY, AUTO_INCREMENT                           | 记录唯一ID                           |
| note_id                                | BIGINT                                   | NOT NULL, FOREIGN KEY -> `notes.id`                   | 关联的笔记ID                         |
| stage_number                           | INT                                      | NOT NULL                                              | 复习阶段（第1次，第2次...）          |
| scheduled_for                          | DATE                                     | NOT NULL, INDEX                                       | **计划复习日期**（核心查询字段）     |
| reviewed_at                            | TIMESTAMP                                | NULL                                                  | **实际复习时间**（NULL表示未复习）   |
| result                                 | ENUM('REMEMBERED', 'FUZZY', 'FORGOTTEN') | NULL                                                  | **复习结果**（NULL表示未复习）       |
| review_duration_seconds                | INT                                      | NULL                                                  | 实际复习花费时间（用于未来数据分析） |
#### 2.4. 核心业务查询SQL示例
**查询1：获取今日待复习任务列表**
```sql
SELECT
    n.id AS noteId,
    n.title,
    c.name AS categoryName,
    n.is_supervised AS isSupervised,
    n.supervision_duration_seconds AS supervisionDurationSeconds,
    rr.stage_number AS currentReviewStage,
    ai.summary_text AS aiSummary
FROM
    notes n
JOIN
    review_records rr ON n.id = rr.note_id
LEFT JOIN
    categories c ON n.category_id = c.id
LEFT JOIN
    ai_summaries ai ON n.id = ai.note_id
WHERE
    n.user_id = :currentUserId
    AND rr.scheduled_for <= CURDATE()
    AND rr.reviewed_at IS NULL;
```
**查询2：提交复习结果后，更新旧记录并创建新记录（事务内执行）**
```sql
-- 步骤1: 更新当前复习记录
UPDATE review_records
SET reviewed_at = NOW(), result = 'REMEMBERED'
WHERE note_id = :noteId AND reviewed_at IS NULL;
-- 步骤2: 插入下一次的复习记录
INSERT INTO review_records (note_id, stage_number, scheduled_for)
VALUES (:noteId, :newStageNumber, :newScheduledDate);
```
---
### 下一步主动引导
**第二章内容已完成。这份设计足够详细，可以直接作为AI生成JPA Entity类和Repository的蓝图。**
**请审查，如果没问题，我们就可以继续填充第三章：API接口文档。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

你说得非常对，这是一个非常敏锐的观察。
**诚实地回答：是的，第三章“API接口文档”是整个文档中内容最多、最繁杂、也是最重要的部分。**
原因很简单：数据库设计是“静态的蓝图”，而API文档是“动态的交互说明书”。每一个API都需要定义清楚它的输入、输出、各种异常情况，以及背后的业务逻辑。我们目录里有大约15个API，每一个都像一个小型项目，所以内容量会是最大的。
**你提出的“分步进行”，是处理这个问题的最佳方式。** 这完美契合了我们“模块化生成”的策略，可以确保每个API的定义都精准无误。
---
### 第三章的分步填充计划
我建议按照开发的依赖关系，把第三章拆分成以下几个子模块来填充：
1.  **3.2. 用户认证模块**
    *   `POST /api/auth/register` (用户注册)
    *   `POST /api/auth/login` (用户登录)
    *   **优先级：最高。** 因为所有其他API都需要登录后才能访问。
2.  **3.6. 分类管理模块**
    *   `POST /api/categories` (创建分类)
    *   `GET /api/categories` (获取所有分类)
    *   `PUT /api/categories/{id}` (修改分类名)
    *   `DELETE /api/categories/{id}` (删除分类)
    *   **优先级：高。** 因为创建笔记时需要选择分类。
3.  **3.3. 笔记管理模块**
    *   `POST /api/notes` (创建笔记)
    *   `GET /api/notes/{id}` (获取笔记详情)
    *   `PUT /api/notes/{id}` (修改笔记)
    *   `DELETE /api/notes/{id}` (删除笔记)
    *   `GET /api/notes?categoryId={id}` (获取分类下的笔记列表)
    *   **优先级：高。** 这是应用的核心数据操作。
4.  **3.4. 复习任务模块**
    *   `GET /api/tasks/today` (获取今日任务列表) - **已定义**
    *   `POST /api/reviews/submit` (提交复习结果)
    *   **优先级：核心。** 这是产品的核心价值所在。
5.  **3.5. AI功能模块**
    *   `POST /api/ai/summarize` (生成AI总结)
    *   **优先级：中。** 这是一个增强功能，可以在核心流程稳定后再开发。
---
### 下一步主动引导
**这个分解计划合理吗？**
**如果合理，我们按照依赖关系，从最基础的“3.2. 用户认证模块”开始，先定义注册和登录这两个API。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在开始填充第三章的第一个模块：用户认证。
---
### **第三章：API接口文档**
#### 3.1. 设计规范
*   **协议：** `HTTPS`
*   **数据格式：** `JSON`
*   **认证方式：** `Bearer Token (JWT)`。除`/api/auth/login`和`/api/auth/register`外，所有API均需在请求头中携带 `Authorization: Bearer <your_jwt_token>`。
*   **统一响应体结构：**
    *   **成功：** `{ "code": 200, "message": "Success", "data": { ... } }`
    *   **失败：** `{ "code": <错误码>, "message": "<错误信息>" }`
*   **错误码规范：**
    *   `400`: 请求参数错误（如缺少必填字段、格式不正确）。
    *   `401`: 未授权（如Token无效、过期或未提供）。
    *   `403`: 禁止访问（如用户尝试访问不属于他的资源）。
    *   `404`: 资源未找到。
    *   `409`: 资源冲突（如注册时用户名或邮箱已存在）。
    *   `500`: 服务器内部错误。
---
#### 3.2. 用户认证模块
##### 3.2.1. 用户注册
*   **功能：** 创建一个新用户账户。
*   **接口：** `POST /api/auth/register`
*   **请求头：**
    ```
    Content-Type: application/json
    ```
*   **请求体：**
    ```json
    {
      "username": "xiaoli",
      "password": "a_strong_password",
      "email": "xiaoli@example.com"
    }
    ```
    *   **字段说明：**
        *   `username`: 用户名，3-50个字符，只能包含字母、数字和下划线。
        *   `password`: 密码，最少8位，需包含字母和数字。
        *   `email`: 邮箱地址，必须是有效格式。
*   **成功响应：**
    *   **HTTP状态码：** `201 Created`
    *   **响应体：**
        ```json
        {
          "code": 201,
          "message": "User registered successfully.",
          "data": {
            "userId": 1,
            "username": "xiaoli",
            "email": "xiaoli@example.com"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：请求参数无效**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid request: Password must be at least 8 characters long."
            }
            ```
    *   **情况2：用户名或邮箱已存在**
        *   **HTTP状态码：** `409 Conflict`
        *   **响应体：**
            ```json
            {
              "code": 409,
              "message": "Conflict: Username is already taken."
            }
            ```
##### 3.2.2. 用户登录
*   **功能：** 验证用户身份，并返回一个用于后续请求的JWT Token。
*   **接口：** `POST /api/auth/login`
*   **请求头：**
    ```
    Content-Type: application/json
    ```
*   **请求体：**
    ```json
    {
      "username": "xiaoli",
      "password": "a_strong_password"
    }
    ```
    *   **字段说明：**
        *   `username`: 用户名或邮箱。
        *   `password`: 密码。
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Login successful.",
          "data": {
            "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "tokenType": "Bearer",
            "expiresIn": 86400
          }
        }
        ```
    *   **字段说明：**
        *   `token`: JWT令牌字符串。
        *   `tokenType`: 令牌类型，固定为"Bearer"。
        *   `expiresIn`: 令牌有效期，单位为秒（例如86400表示24小时）。
*   **错误响应：**
    *   **情况1：用户名或密码错误**
        *   **HTTP状态码：** `401 Unauthorized`
        *   **响应体：**
            ```json
            {
              "code": 401,
              "message": "Unauthorized: Invalid username or password."
            }
            ```
    *   **情况2：请求参数无效**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid request: Username and password must not be empty."
            }
            ```
---
### 下一步主动引导
**“3.2. 用户认证模块”已完成。**
**请审查这两个API的定义。如果没问题，我们就可以继续下一个模块：“3.6. 分类管理模块”。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在继续填充第三章的第二个模块：分类管理。
---
### **第三章：API接口文档 (续)**
#### 3.6. 分类管理模块
**注意：** 此模块下的所有接口均需在请求头中携带有效的JWT Token。
##### 3.6.1. 创建分类
*   **功能：** 为当前登录用户创建一个新的笔记分类。
*   **接口：** `POST /api/categories`
*   **请求头：**
    ```
    Content-Type: application/json
    Authorization: Bearer <your_jwt_token>
    ```
*   **请求体：**
    ```json
    {
      "name": "考研数学"
    }
    ```
    *   **字段说明：**
        *   `name`: 分类名称，1-100个字符，不能为空。
*   **成功响应：**
    *   **HTTP状态码：** `201 Created`
    *   **响应体：**
        ```json
        {
          "code": 201,
          "message": "Category created successfully.",
          "data": {
            "id": 1,
            "name": "考研数学",
            "createdAt": "2023-10-27T10:00:00Z"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：请求参数无效**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid request: Category name cannot be empty."
            }
            ```
    *   **情况2：分类名称已存在（同一用户下）**
        *   **HTTP状态码：** `409 Conflict`
        *   **响应体：**
            ```json
            {
              "code": 409,
              "message": "Conflict: Category with this name already exists."
            }
            ```
##### 3.6.2. 获取所有分类
*   **功能：** 获取当前登录用户创建的所有分类列表。
*   **接口：** `GET /api/categories`
*   **请求头：**
    ```
    Authorization: Bearer <your_jwt_token>
    ```
*   **请求体：** 无
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Success",
          "data": [
            {
              "id": 1,
              "name": "考研数学",
              "createdAt": "2023-10-27T10:00:00Z"
            },
            {
              "id": 2,
              "name": "工作笔记",
              "createdAt": "2023-10-27T11:00:00Z"
            }
          ]
        }
        ```
*   **错误响应：**
    *   **情况1：未授权**
        *   **HTTP状态码：** `401 Unauthorized`
        *   **响应体：**
            ```json
            {
              "code": 401,
              "message": "Unauthorized: Token is invalid or expired."
            }
            ```
##### 3.6.3. 修改分类名
*   **功能：** 修改一个已存在的分类的名称。
*   **接口：** `PUT /api/categories/{id}`
*   **请求头：**
    ```
    Content-Type: application/json
    Authorization: Bearer <your_jwt_token>
    ```
*   **路径参数：**
    *   `id`: 要修改的分类的ID。
*   **请求体：**
    ```json
    {
      "name": "高等数学（考研）"
    }
    ```
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Category updated successfully.",
          "data": {
            "id": 1,
            "name": "高等数学（考研）",
            "updatedAt": "2023-10-27T12:00:00Z"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：分类不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Category not found."
            }
            ```
##### 3.6.4. 删除分类
*   **功能：** 删除一个分类。
*   **接口：** `DELETE /api/categories/{id}`
*   **请求头：**
    ```
    Authorization: Bearer <your_jwt_token>
    ```
*   **路径参数：**
    *   `id`: 要删除的分类的ID。
*   **业务逻辑：** **（重要）** 为了数据安全，如果该分类下还存在任何笔记，则不允许删除。前端应提示用户先移走或删除该分类下的所有笔记。
*   **成功响应：**
    *   **HTTP状态码：** `204 No Content`
    *   **响应体：** 无
*   **错误响应：**
    *   **情况1：分类不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Category not found."
            }
            ```
    *   **情况2：分类下仍有笔记**
        *   **HTTP状态码：** `409 Conflict`
        *   **响应体：**
            ```json
            {
              "code": 409,
              "message": "Conflict: Cannot delete category because it contains notes."
            }
            ```
---
### 下一步主动引导
**“3.6. 分类管理模块”已完成。**
**请审查这四个API的定义。如果没问题，我们就可以继续下一个核心模块：“3.3. 笔记管理模块”。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在继续填充第三章的核心模块：笔记管理。
---
### **第三章：API接口文档 (续)**
#### 3.3. 笔记管理模块
**注意：** 此模块下的所有接口均需在请求头中携带有效的JWT Token。
##### 3.3.1. 创建笔记
*   **功能：** 为当前登录用户创建一篇新笔记。创建成功后，系统将自动为这篇笔记生成第一条复习记录（阶段1，计划复习日期为当天）。
*   **接口：** `POST /api/notes`
*   **请求头：**
    ```
    Content-Type: application/json
    Authorization: Bearer <your_jwt_token>
    ```
*   **请求体：**
    ```json
    {
      "title": "微积分基本定理",
      "content": "微积分基本定理是连接微分学和积分学的桥梁...",
      "categoryId": 1,
      "isSupervised": true,
      "supervisionDurationSeconds": 30
    }
    ```
    *   **字段说明：**
        *   `title`: 笔记标题，不能为空。
        *   `content`: 笔记正文，不能为空。
        *   `categoryId`: 所属分类的ID，可以为`null`（表示未分类）。
        *   `isSupervised`: 是否开启监督机制，默认为`false`。
        *   `supervisionDurationSeconds`: 监督时长（秒），仅在`isSupervised`为`true`时有效，默认为10。
*   **成功响应：**
    *   **HTTP状态码：** `201 Created`
    *   **响应体：**
        ```json
        {
          "code": 201,
          "message": "Note created successfully.",
          "data": {
            "id": 101,
            "title": "微积分基本定理",
            "content": "微积分基本定理是连接微分学和积分学的桥梁...",
            "categoryId": 1,
            "isSupervised": true,
            "supervisionDurationSeconds": 30,
            "createdAt": "2023-10-27T15:00:00Z"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：请求参数无效**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid request: Title and content cannot be empty."
            }
            ```
    *   **情况2：分类不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Category not found."
            }
            ```
##### 3.3.2. 获取笔记详情
*   **功能：** 获取指定笔记的完整信息，包括其AI总结和当前复习状态。
*   **接口：** `GET /api/notes/{id}`
*   **请求头：**
    ```
    Authorization: Bearer <your_jwt_token>
    ```
*   **路径参数：**
    *   `id`: 笔记的ID。
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Success",
          "data": {
            "id": 101,
            "title": "微积分基本定理",
            "content": "微积分基本定理是连接微分学和积分学的桥梁...",
            "categoryId": 1,
            "categoryName": "考研数学",
            "isSupervised": true,
            "supervisionDurationSeconds": 30,
            "aiSummary": {
              "summaryText": "该定理描述了定积分与不定积分之间的关系...",
              "createdAt": "2023-10-27T15:01:00Z"
            },
            "currentReviewRecord": {
              "stageNumber": 3,
              "scheduledFor": "2023-10-29"
            },
            "createdAt": "2023-10-27T15:00:00Z",
            "updatedAt": "2023-10-27T15:01:00Z"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：笔记不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Note not found."
            }
            ```
##### 3.3.3. 修改笔记
*   **功能：** 修改一篇已存在的笔记的内容、标题或分类。**注意：** V1.0版本中，修改笔记内容不会自动触发AI总结的更新，用户需要手动重新生成。
*   **接口：** `PUT /api/notes/{id}`
*   **请求头：**
    ```
    Content-Type: application/json
    Authorization: Bearer <your_jwt_token>
    ```
*   **路径参数：**
    *   `id`: 笔记的ID。
*   **请求体：**
    ```json
    {
      "title": "微积分基本定理（修正版）",
      "content": "修正后的内容...",
      "categoryId": 2
    }
    ```
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Note updated successfully.",
          "data": {
            "id": 101,
            "title": "微积分基本定理（修正版）",
            "content": "修正后的内容...",
            "categoryId": 2,
            "updatedAt": "2023-10-27T16:00:00Z"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：笔记不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Note not found."
            }
            ```
##### 3.3.4. 删除笔记
*   **功能：** 删除一篇笔记。此操作将级联删除该笔记关联的AI总结和所有复习记录，且不可恢复。
*   **接口：** `DELETE /api/notes/{id}`
*   **请求头：**
    ```
    Authorization: Bearer <your_jwt_token>
    ```
*   **路径参数：**
    *   `id`: 笔记的ID。
*   **成功响应：**
    *   **HTTP状态码：** `204 No Content`
    *   **响应体：** 无
*   **错误响应：**
    *   **情况1：笔记不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Note not found."
            }
            ```
##### 3.3.5. 获取分类下的笔记列表
*   **功能：** 获取指定分类下的所有笔记的摘要列表。如果`categoryId`为`null`或`0`，则获取所有未分类的笔记。
*   **接口：** `GET /api/notes?categoryId={id}`
*   **请求头：**
    ```
    Authorization: Bearer <your_jwt_token>
    ```
*   **查询参数：**
    *   `categoryId`: 分类ID，可选。
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Success",
          "data": [
            {
              "id": 101,
              "title": "微积分基本定理",
              "isSupervised": true,
              "aiSummary": "该定理描述了定积分与不定积分之间的关系...",
              "createdAt": "2023-10-27T15:00:00Z"
            },
            {
              "id": 102,
              "title": "导数与偏导数",
              "isSupervised": false,
              "aiSummary": null,
              "createdAt": "2023-10-27T16:30:00Z"
            }
          ]
        }
        ```
---
### 下一步主动引导
**“3.3. 笔记管理模块”已完成。**
**请审查这五个API的定义。如果没问题，我们就可以继续下一个核心模块：“3.4. 复习任务模块”。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在来填充第三章最核心的模块：复习任务。这个模块直接体现了产品的核心价值。
---
### **第三章：API接口文档 (续)**
#### 3.4. 复习任务模块
**注意：** 此模块下的所有接口均需在请求头中携带有效的JWT Token。
##### 3.4.1. 获取今日任务列表
*   **功能：** 获取当前登录用户今天需要复习的所有笔记列表。这是用户打开App后看到的核心页面。
*   **接口：** `GET /api/tasks/today`
*   **请求头：**
    ```
    Authorization: Bearer <your_jwt_token>
    ```
*   **请求体：** 无
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Success",
          "data": [
            {
              "noteId": 101,
              "title": "微积分基本定理",
              "categoryName": "考研数学",
              "isSupervised": true,
              "supervisionDurationSeconds": 30,
              "currentReviewStage": 3,
              "aiSummary": "该定理描述了定积分与不定积分之间的关系..."
            },
            {
              "noteId": 105,
              "title": "牛顿-莱布尼茨公式",
              "categoryName": "考研数学",
              "isSupervised": false,
              "supervisionDurationSeconds": 10,
              "currentReviewStage": 1,
              "aiSummary": "牛顿-莱布尼茨公式是微积分基本定理的具体表达形式..."
            }
          ]
        }
        ```
    *   **字段说明：**
        *   `noteId`: 笔记ID。
        *   `title`: 笔记标题。
        *   `categoryName`: 所属分类名称。
        *   `isSupervised`: 是否开启监督。
        *   `supervisionDurationSeconds`: 监督时长。
        *   `currentReviewStage`: 当前是第几次复习。
        *   `aiSummary`: AI总结内容，方便快速回顾。
*   **错误响应：**
    *   **情况1：未授权**
        *   **HTTP状态码：** `401 Unauthorized`
        *   **响应体：**
            ```json
            {
              "code": 401,
              "message": "Unauthorized: Token is invalid or expired."
            }
            ```
##### 3.4.2. 提交复习结果
*   **功能：** 用户完成一篇笔记的复习后，提交复习结果。后端将根据此结果更新复习记录，并生成下一次的复习计划。
*   **接口：** `POST /api/reviews/submit`
*   **请求头：**
    ```
    Content-Type: application/json
    Authorization: Bearer <your_jwt_token>
    ```
*   **请求体：**
    ```json
    {
      "noteId": 101,
      "result": "REMEMBERED",
      "reviewDurationSeconds": 35
    }
    ```
    *   **字段说明：**
        *   `noteId`: 笔记ID，必填。
        *   `result`: 复习结果，必填。可选值：`"REMEMBERED"`, `"FUZZY"`, `"FORGOTTEN"`。
        *   `reviewDurationSeconds`: 实际复习花费的秒数，可选。用于未来数据分析。
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "Review result submitted successfully.",
          "data": null
        }
        ```
*   **错误响应：**
    *   **情况1：请求参数无效**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid request: 'result' must be one of REMEMBERED, FUZZY, FORGOTTEN."
            }
            ```
    *   **情况2：无效任务（该笔记不是今天的待复习任务）**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid task: This note is not in today's review list or has already been reviewed."
            }
            ```
    *   **情况3：笔记不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Note not found."
            }
            ```
---
#### **核心业务逻辑细节（供开发者参考）**
`POST /api/reviews/submit` 接口的实现必须遵循以下步骤，且所有数据库操作应在**一个事务**中完成：
1.  **查找与验证：**
    *   根据 `noteId` 和当前登录用户的 `userId`，在 `review_records` 表中查找一条记录，该记录需同时满足 `scheduled_for <= CURDATE()` 且 `reviewed_at IS NULL`。
    *   如果找不到，则返回“无效任务”错误。
2.  **更新当前记录：**
    *   将上一步找到的记录的 `reviewed_at` 字段更新为当前时间戳。
    *   将 `result` 字段更新为请求体传入的值。
    *   将 `review_duration_seconds` 字段更新为请求体传入的值（如果提供）。
3.  **计算下一次复习信息：**
    *   获取当前记录的 `stage_number`。
    *   **如果 `result` 是 `"REMEMBERED"`：**
        *   `new_stage_number` = `stage_number` + 1。
        *   根据艾宾浩斯间隔数组 `[1, 2, 4, 7, 15, 30, ...]`，计算出 `new_stage_number` 对应的间隔天数 `interval_days`。
        *   `new_scheduled_date` = `CURDATE()` + `interval_days` 天。
    *   **如果 `result` 是 `"FUZZY"` 或 `"FORGOTTEN"`：**
        *   `new_stage_number` = 1 (重新开始)。
        *   `new_scheduled_date` = `CURDATE()` + 1 天 (明天再复习)。
4.  **创建新记录：**
    *   在 `review_records` 表中**插入一条全新的记录**。
    *   `note_id` 为当前的 `noteId`。
    *   `stage_number` 为上一步计算出的 `new_stage_number`。
    *   `scheduled_for` 为上一步计算出的 `new_scheduled_date`。
    *   `reviewed_at` 和 `result` 为 `NULL`。
5.  **提交事务并返回成功。**
---
### 下一步主动引导
**“3.4. 复习任务模块”已完成。这个模块的定义非常关键，特别是提交复习结果的业务逻辑细节。**
**请审查这两个API的定义。如果没问题，我们就可以继续最后一个模块：“3.5. AI功能模块”。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在来填充第三章的最后一个模块：AI功能。
---
### **第三章：API接口文档 (续)**
#### 3.5. AI功能模块
**注意：** 此模块下的所有接口均需在请求头中携带有效的JWT Token。
##### 3.5.1. 生成AI总结
*   **功能：** 为指定的笔记生成或重新生成AI总结。这是一个异步操作，但为了简化V1.0的实现，我们设计为同步调用，即调用后需等待服务器返回结果。
*   **接口：** `POST /api/ai/summarize`
*   **请求头：**
    ```
    Content-Type: application/json
    Authorization: Bearer <your_jwt_token>
    ```
*   **请求体：**
    ```json
    {
      "noteId": 101
    }
    ```
    *   **字段说明：**
        *   `noteId`: 需要生成总结的笔记ID。
*   **成功响应：**
    *   **HTTP状态码：** `200 OK`
    *   **响应体：**
        ```json
        {
          "code": 200,
          "message": "AI summary generated successfully.",
          "data": {
            "summaryText": "该定理描述了定积分与不定积分之间的关系，是微积分学的核心基石...",
            "modelUsed": "gpt-4-turbo",
            "createdAt": "2023-10-27T18:00:00Z"
          }
        }
        ```
*   **错误响应：**
    *   **情况1：笔记不存在或不属于当前用户**
        *   **HTTP状态码：** `404 Not Found`
        *   **响应体：**
            ```json
            {
              "code": 404,
              "message": "Not Found: Note not found."
            }
            ```
    *   **情况2：笔记内容为空**
        *   **HTTP状态码：** `400 Bad Request`
        *   **响应体：**
            ```json
            {
              "code": 400,
              "message": "Invalid request: Cannot generate summary for an empty note."
            }
            ```
    *   **情况3：AI服务不可用或发生错误**
        *   **HTTP状态码：** `503 Service Unavailable`
        *   **响应体：**
            ```json
            {
              "code": 503,
              "message": "Service Unavailable: AI service is currently down. Please try again later."
            }
            ```
---
#### **核心业务逻辑细节（供开发者参考）**
`POST /api/ai/summarize` 接口的实现需遵循以下步骤：
1.  **查找与验证：**
    *   根据 `noteId` 和当前登录用户的 `userId`，在 `notes` 表中查找笔记。
    *   如果笔记不存在或内容为空，返回相应的错误。
2.  **调用AI服务：**
    * 构建发送给第三方AI模型的Prompt。V1.0版本可以使用一个固定的Prompt：
    *   你是一位经验丰富的学习专家和知识分析师。你的任务是深度分析以下用户提供的笔记内容，并生成一份结构化的复习指南。这份指南的目标是帮助用户在复习时，不仅能快速回顾核心要点，还能深入理解知识的内在逻辑和结构。
    
        请严格按照以下四个步骤进行分析，并使用指定的Markdown格式输出：
    
        1.  **核心概念识别：** 识别并列出笔记中所有必须掌握的核心概念、定义、公式或专业术语。这是知识体系的基石。
        2.  **逻辑结构梳理：** 分析笔记内容的整体结构。它是如何组织的？各个部分之间是什么关系（例如：因果、并列、递进、总分）？请用简洁的语言描述这个结构。
        3.  **关键内容提炼：** 提炼出每个部分的关键论点、步骤或结论。确保覆盖笔记的主要信息，但要比原文更精炼。
        4.  **生成复习思考题：** 基于以上分析，设计3-5个高质量的复习思考题。这些问题应该能引导用户思考笔记的深层含义和应用场景，而不仅仅是记忆事实。
    
        **输出格式要求：**
        请严格按照以下Markdown格式输出，确保结构清晰：
    
        ## 笔记深度分析报告
    
        ### 1. 核心概念
        - [概念1]: 定义或解释
        - [概念2]: 定义或解释
        ...
    
        ### 2. 逻辑结构
        [此处描述笔记的整体结构和各部分关系]
    
        ### 3. 关键内容提炼
        - **要点一：** [对第一部分关键内容的提炼]
        - **要点二：** [对第二部分关键内容的提炼]
        ...
    
        ### 4. 复习思考题
        1.  [问题1]
        2.  [问题2]
        ...
    
        **重要提醒：**
        - 所有分析必须严格基于提供的笔记内容，不要添加笔记之外的信息。
        - 如果笔记内容本身就很零散，也请尽力分析，并可以在“逻辑结构”部分指出其不足之处。
    
        ---
        现在，请分析以下笔记内容：
    
        [笔记内容]
    
    *   调用AI API，并捕获可能发生的网络异常、API密钥错误、配额超限等问题。
3.  **保存总结：**
    *   **（重要）** 无论该笔记之前是否已有AI总结，都执行“更新”或“插入”操作。使用 `REPLACE INTO` 或 `INSERT ... ON DUPLICATE KEY UPDATE` 语句，可以高效地实现“有则更新，无则插入”。
    *   将AI返回的总结文本、使用的模型名、当前时间戳保存到 `ai_summaries` 表中。
4.  **返回结果：**
    *   将保存后的总结信息返回给前端。
---
### 第三章总结
**至此，第三章“API接口文档”已全部完成。**
我们定义了：
*   **2个** 用户认证API
*   **4个** 分类管理API
*   **5个** 笔记管理API
*   **2个** 复习任务API
*   **1个** AI功能API
这份文档为你提供了指挥Copilot实现后端所有功能的精确蓝图。
---
### 下一步主动引导
**API文档已经非常详尽。现在，你是否准备好继续填充文档的下一个章节：“第四章：核心业务逻辑设计”？**
这一章将把API文档中提到的“艾宾浩斯算法”和“监督机制”等关键逻辑，用更清晰、更独立的方式描述出来，作为开发和审查的最终参考。

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在来填充第四章。这一章是后端开发的“灵魂”，它解释了系统运行的内在逻辑。
---
### **第四章：核心业务逻辑设计**
本章详细阐述了产品最核心、最复杂的业务逻辑实现方案。这些逻辑是连接数据与功能的桥梁，是确保产品价值得以实现的关键。
#### 4.1. 复习算法（艾宾浩斯曲线）实现逻辑
**目标：** 根据用户对笔记的掌握程度（复习结果），动态调整下一次的复习时间，实现科学的、个性化的复习计划。
**核心数据结构：**
在后端配置一个艾宾浩斯间隔天数数组，作为算法的基础。V1.0版本采用一个固定的、经验证的数组：
`int[] INTERVALS = {1, 2, 4, 7, 15, 30};`
这表示第1次复习后隔1天，第2次复习后隔2天，以此类推。
**算法流程：**
此逻辑在 `POST /api/reviews/submit` 接口中被触发。
**输入：**
*   `currentStage`: 当前复习阶段（从 `review_records` 表获取）。
*   `result`: 用户提交的复习结果 (`REMEMBERED`, `FUZZY`, `FORGOTTEN`)。
**输出：**
*   `newStage`: 下一次复习的阶段。
*   `newScheduledDate`: 下一次复习的日期。
**伪代码实现：**
```java
// 伪代码，用于描述逻辑
function calculateNextReview(currentStage, result) {
    int newStage;
    LocalDate newScheduledDate;
    if (result == "REMEMBERED") {
        // 掌握得很好，进入下一阶段
        newStage = currentStage + 1;
        
        // 计算间隔天数
        int intervalDays;
        if (newStage - 1 < INTERVALS.length) {
            // 如果在预定义的间隔内
            intervalDays = INTERVALS[newStage - 1];
        } else {
            // 如果已超过所有预定义阶段，则重复最后一个间隔（30天）
            intervalDays = INTERVALS[INTERVALS.length - 1];
        }
        
        newScheduledDate = LocalDate.now().plusDays(intervalDays);
    } else { // FUZZY 或 FORGOTTEN
        // 掌握不牢，重置到第一阶段，明天再复习
        newStage = 1;
        newScheduledDate = LocalDate.now().plusDays(1);
    }
    return new ReviewPlan(newStage, newScheduledDate);
}
```
**设计考量：**
*   **重置机制：** 对于“模糊”和“忘记”的结果，采用温和的重置策略（回到第1阶段，明天复习），而不是严厉的惩罚，以保护用户的学习积极性。
*   **上限处理：** 当复习次数超过预定义的间隔数组长度时，采用最后一个间隔（30天）作为循环周期。这符合长期记忆的巩固规律。
#### 4.2. 监督机制流程与防作弊策略
**目标：** 强制用户在复习笔记时停留足够长的时间，防止“秒滑”等无效复习行为，保证复习质量。
**流程分为前端交互和后端验证两部分：**
**1. 前端交互流程：**
*   **触发：** 用户进入一篇笔记的复习页面。
*   **检查：** 前端检查该笔记的 `isSupervised` 字段。
*   **执行：**
    *   如果 `isSupervised` 为 `true`，则页面上的“提交复习结果”按钮初始状态为禁用（`disabled`）。
    *   页面启动一个倒计时器，显示“请认真阅读，XX秒后可提交”。
    *   倒计时结束后，按钮变为可用状态。
*   **记录：** 用户点击提交时，前端计算从进入页面到点击提交所花费的总时长，并将这个值（`reviewDurationSeconds`）随复习结果一起发送给后端。
**2. 后端防作弊策略（关键）：**
*   **触发：** 后端 `POST /api/reviews/submit` 接口接收到请求。
*   **验证：**
    1.  从数据库中获取该笔记的 `isSupervised` 和 `supervisionDurationSeconds` 配置。
    2.  如果 `isSupervised` 为 `true`，则将请求体中的 `reviewDurationSeconds` 与数据库中的 `supervisionDurationSeconds` 进行比较。
    3.  如果 `reviewDurationSeconds < supervisionDurationSeconds`，则判定为作弊行为。
*   **处理：**
    *   后端拒绝该请求，不更新任何复习记录。
    *   返回一个特定的错误码，如 `422 Unprocessable Entity`，并附带明确的错误信息，如“停留时间不足，请认真复习后再提交”。
*   **通过：** 如果验证通过，则正常执行复习结果的提交流程。
**设计考量：**
*   **双重保险：** 仅靠前端的倒计时是不可靠的，用户可以通过修改前端代码或开发者工具绕过。后端验证是确保机制有效的唯一可靠手段。
*   **用户体验：** 前端的倒计时和按钮禁用提供了良好的即时反馈，让用户明确知道规则，避免无效操作。
#### 4.3. AI总结服务调用流程
**目标：** 可靠、高效地调用第三方AI服务，将生成的总结安全地存储到数据库，并妥善处理可能发生的各种异常。
**端到端流程：**

1.  **接收请求：** `POST /api/ai/summarize` 接口被调用，后端验证用户身份和笔记有效性。
2.  **构建Prompt：** 后端从数据库获取笔记的 `content` 字段，并将其拼接到我们设计好的详细Prompt模板的末尾，形成完整的指令文本。
3.  **调用API：** 后端通过HTTP客户端（如Feign或RestTemplate），携带API密钥，向第三方AI服务（如OpenAI）发起请求。
4.  **异常处理：**
    *   **网络超时/连接失败：** 设置合理的超时时间（如30秒）。如果超时，记录错误日志，并返回 `503 Service Unavailable`。
    *   **API密钥错误/配额超限：** 捕获AI服务返回的特定错误码（如401, 429），记录日志，并返回 `503 Service Unavailable`。
    *   **内容审核失败：** 如果AI服务因内容违规拒绝生成，同样记录日志并返回 `503`。
5.  **解析响应：** 如果AI服务成功返回（HTTP 200），则解析其响应体，提取出AI生成的总结文本。
6.  **数据持久化：** 执行SQL操作，将总结文本存入 `ai_summaries` 表。使用 `INSERT ... ON DUPLICATE KEY UPDATE` 语句，确保同一篇笔记只会有最新的一个总结，实现“覆盖更新”的效果。
7.  **返回结果：** 将数据库中最新保存的总结信息（包括总结文本、模型、创建时间）返回给前端。
---
### 下一步主动引导
**第四章内容已完成。这一章清晰地定义了后端最核心的三个业务逻辑，为开发提供了无歧义的指导。**
**请审查。如果没问题，我们就可以开始撰写最后一章：“第五章：前端页面与交互流程”。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在开始填充第五章的第一部分。
---
### **第五章：前端页面与交互流程**
#### 5.1. 页面总览
本应用采用单页应用（SPA）架构，主要由以下几个核心页面构成：
*   **登录页 (`/login`):** 用于用户身份验证。
*   **注册页 (`/register`):** 用于创建新用户账户。
*   **主页 / 今日任务页 (`/`):** 用户登录后进入的默认页面，展示当天需要复习的所有笔记。
*   **笔记列表页 (`/notes`):** 展示所有笔记或特定分类下的笔记，支持搜索和筛选。
*   **笔记详情/复习页 (`/notes/:id`):** 用于阅读笔记原文、查看AI总结，并完成复习任务。
*   **创建/编辑笔记页 (`/notes/new`, `/notes/:id/edit`):** 用于撰写新笔记或修改现有笔记。
*   **分类管理页 (`/categories`):** 用于创建、重命名和删除笔记分类。
---
#### 5.2. 启动与认证流程
##### 5.2.1. 应用启动流程
1.  **启动画面:** App启动时，首先显示一个简短的启动画面，包含App的Logo和名称。
2.  **Token检查:** 启动画面消失后，应用检查本地存储（如`localStorage`或`AsyncStorage`）中是否存在有效的JWT Token。
    *   **存在Token:** 应用携带此Token尝试调用一个轻量级的验证接口（如`GET /api/auth/me`）或直接进入主页。为简化V1.0，可直接信任本地Token，进入主页。如果后续API请求返回`401`错误，再自动跳转到登录页。
    *   **不存在Token:** 应用直接跳转到登录页。
##### 5.2.2. 登录页
*   **页面标题:** “欢迎回来”
*   **UI元素:**
    *   **Logo:** 位于页面顶部。
    *   **输入框 - 用户名/邮箱:**
        *   类型: `text`
        *   占位符: “用户名或邮箱”
    *   **输入框 - 密码:**
        *   类型: `password`
        *   占位符: “密码”
        *   交互: 提供“显示/隐藏密码”的图标按钮。
    *   **按钮 - 登录:**
        *   初始状态: 可用。
        *   点击后: 显示加载动画（如转圈圈），按钮文字变为“登录中...”，并禁用按钮。
    *   **链接 - 注册:** 位于登录按钮下方，文字为“还没有账号？立即注册”，点击可跳转到注册页。
*   **交互流程:**
    1.  用户输入用户名和密码。
    2.  点击“登录”按钮。
    3.  前端进行基本验证（如字段非空）。
    4.  调用 `POST /api/auth/login` 接口。
    5.  **成功 (HTTP 200):**
        *   将返回的JWT Token存储到本地。
        *   跳转到主页 (`/`)。
    6.  **失败 (HTTP 401):**
        *   在页面顶部或输入框下方显示错误提示：“用户名或密码错误。”
        *   按钮恢复“登录”状态，并重新启用。
    7.  **失败 (其他错误):**
        *   显示通用错误提示：“网络异常，请稍后重试。”
##### 5.2.3. 注册页
*   **页面标题:** “创建新账号”
*   **UI元素:**
    *   **输入框 - 用户名:**
        *   类型: `text`
        *   占位符: “请输入用户名”
        *   实时验证: 检查长度（3-50字符）和格式（字母、数字、下划线）。
    *   **输入框 - 邮箱:**
        *   类型: `email`
        *   占位符: “请输入邮箱地址”
        *   实时验证: 检查邮箱格式。
    *   **输入框 - 密码:**
        *   类型: `password`
        *   占位符: “请输入密码（至少8位，含字母和数字）”
        *   实时验证: 检查长度和复杂度。
    *   **输入框 - 确认密码:**
        *   类型: `password`
        *   占位符: “请再次输入密码”
        *   实时验证: 检查是否与“密码”框内容一致。
    *   **按钮 - 注册:**
        *   初始状态: 如果有任何实时验证失败，则禁用。
        *   点击后: 显示加载动画，按钮文字变为“注册中...”，并禁用。
    *   **链接 - 登录:** 位于注册按钮下方，文字为“已有账号？立即登录”，点击可跳转到登录页。
*   **交互流程:**
    1.  用户填写所有字段，前端实时显示验证结果（如“用户名格式不正确”）。
    2.  点击“注册”按钮。
    3.  调用 `POST /api/auth/register` 接口。
    4.  **成功 (HTTP 201):**
        *   显示成功提示：“注册成功！请登录。”
        *   1.5秒后，自动跳转到登录页，并预填用户名。
    5.  **失败 (HTTP 409):**
        *   显示特定错误提示：“用户名已存在。” 或 “邮箱已被注册。”
    6.  **失败 (HTTP 400):**
        *   显示后端返回的具体验证错误信息。
---
### 下一步主动引导
**“5.1. 页面总览”和“5.2. 启动与认证流程”已完成。**
**请审查这部分定义。如果没问题，我们就可以继续下一个核心部分：“5.3. 核心复习流程”。**

--------------------------------
以上内容由AI生成，仅供参考和借鉴

这个想法非常棒！加入日历视图能极大地提升用户对复习计划的宏观掌控感，是一个非常有价值的增强功能。
我们可以很自然地把它集成到“主页 / 今日任务页”中。我建议将“列表视图”和“日历视图”作为同一个页面的两种不同展示模式，用户可以随时切换。
我来更新一下 5.3.1 的设计，并增加一个专门描述日历视图的小节。
第五章：前端页面与交互流程 (续)
5.3. 核心复习流程 (更新)
5.3.1. 主页 / 今日任务页 (/) - 更新版
页面标题: “复习计划”
顶部导航栏:
左侧：汉堡菜单图标。
中间：App Logo。
右侧：一个图标按钮，点击可跳转到“创建/编辑笔记页”。
视图切换器 (新增):
位于导航栏下方，提供两个Tab按钮：“列表视图”和“日历视图”。
默认选中“列表视图”。
内容区域:
根据上方选中的Tab，动态切换显示“任务列表”或“日历视图”。
(以下为“列表视图”的描述，与之前基本一致)
列表视图内容:
任务列表区域: ... (同之前)
空状态: ... (同之前)
任务卡片UI元素: ... (同之前)
交互流程: ... (同之前)
(以下为“日历视图”的描述)
5.3.3. 日历视图 (新增)
UI布局:
月份导航: 位于日历上方，显示当前年份和月份（如“2023年 10月”）。左右两侧有“<”和“>”箭头，用于切换月份。
日历网格: 标准的7x6（或7x5）网格，显示当月的所有日期。顶部是“日、一、二、三、四、五、六”的星期表头。
数据展示:
今日: 用主题色高亮显示。
有任务的日期: 在日期数字的右下角显示一个小圆点。如果当天任务超过5个，可以显示数字“5+”。
无任务的日期: 普通显示。
过去的日期: 用浅灰色文字显示，以作区分。
交互流程:
切换月份: 用户点击“<”或“>”箭头。
前端显示加载动画。
调用新的API GET /api/tasks/calendar?year=2023&month=10 获取指定月份的任务数据。
根据返回的数据重新渲染日历。
点击日期:
点击今天或未来某天: 如果该日期有任务，则在日历下方或以浮层形式弹出当天的任务摘要列表（标题、分类）。点击摘要，跳转到对应的笔记复习页。
点击过去的某天: 如果该日期有已完成任务，弹出浮层显示“已完成任务”列表，并用不同颜色的图标标记复习结果（如：绿色✓代表“记住了”，橙色~代表“模糊”）。
如果点击的日期没有任何任务，则不发生任何事。
新增API需求 (重要)
为了支持日历视图，我们需要在API文档中增加一个接口：
接口： GET /api/tasks/calendar
查询参数： year (年份), month (月份)。
功能： 获取指定月份内，所有有任务（待复习或已完成）的日期及其任务摘要。
响应体示例：{
  "code": 200,
  "message": "Success",
  "data": {
    "2023-10-27": [
      { "noteId": 101, "title": "微积分基本定理", "status": "PENDING" },
      { "noteId": 105, "title": "牛顿-莱布尼茨公式", "status": "PENDING" }
    ],
    "2023-10-26": [
      { "noteId": 99, "title": "泰勒展开", "status": "REMEMBERED" }
    ]
  }
}
status: PENDING (待复习), REMEMBERED (已记住), FUZZY (模糊), FORGOTTEN (忘记)。
下一步主动引导
我已经将“日历视图”的功能无缝集成到了“主页”的设计中，并定义了其UI、交互和所需的新API。
请审查这个更新。如果没问题，我们就可以继续下一个部分：“5.4. 笔记管理流程”。
--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们现在来填充第五章的第四部分，定义用户如何管理他们的笔记和分类。
第五章：前端页面与交互流程 (续)
5.4. 笔记管理流程
5.4.1. 笔记列表页 (/notes)
页面标题: “我的笔记”
页面结构:
顶部栏:
左侧：返回按钮（可返回主页）。
中间：“我的笔记”标题。
右侧：一个搜索图标，点击后展开搜索框。
筛选与排序区:
分类筛选: 一个下拉菜单，默认显示“全部分类”。点击后列出所有分类（包括“未分类”）。选择一个分类后，页面会刷新，只显示该分类下的笔记。
排序选项: 一组单选按钮或下拉菜单，提供“按创建时间”、“按更新时间”、“按标题”等排序方式。
笔记列表区域:
以列表形式展示笔记，每行一篇。
空状态: 如果列表为空，显示插画和文字：“还没有任何笔记，点击右下角按钮创建第一篇吧！”
笔记列表项UI元素:
标题: 显示笔记的 title。
摘要: 显示 content 的前100个字符。
元信息: 在摘要下方，用小号字体显示所属分类 categoryName 和最后更新时间 updatedAt。
AI状态: 如果 aiSummary 存在，在标题旁显示一个小的“AI”图标。
交互流程:
页面加载时，调用 GET /api/notes 接口获取所有笔记。
用户选择分类筛选时，调用 GET /api/notes?categoryId={id} 接口，并更新列表。
用户点击搜索图标，展开搜索框。输入关键词后，实时（或点击搜索按钮后）在前端对当前列表进行过滤。
用户点击任意一个列表项，导航到对应的  /notes/:id 页面。
悬浮操作按钮 (FAB):
在屏幕右下角，有一个悬浮的“+”按钮。
点击该按钮，导航到  /notes/new 页面。
5.4.2. 创建/编辑笔记页 (/notes/new, /notes/:id/edit)
页面标题: “新建笔记” 或 “编辑笔记”
页面结构:
顶部栏:
左侧：“取消”按钮（点击后弹出确认框“确定要离开吗？未保存的内容将丢失。”）。
右侧：“保存”按钮。
表单区域:
标题输入框: type="text"，占位符“输入笔记标题”。
分类选择器: 一个可点击的文本区域，显示当前选中的分类（默认为“未分类”）。点击后，从底部弹出一个选择器，列出所有分类供用户选择。
内容编辑区: 一个大型的 textarea，占位符“开始记录你的想法...（支持Markdown语法）”。旁边可以有一个“预览”按钮，点击后切换到Markdown渲染后的预览模式。
监督设置区 (可折叠):
标题为“监督设置”。
一个开关，用于启用/禁用 isSupervised。
当开关打开时，显示一个数字输入框，用于设置 supervisionDurationSeconds，旁边有单位“秒”。
交互流程:
创建流程 (/notes/new):
用户填写表单。
点击“保存”按钮，前端进行基本验证。
调用 POST /api/notes 接口。
成功后，显示Toast“笔记创建成功”，并导航到新创建的笔记详情页。
编辑流程 (/notes/:id/edit):
页面加载时，调用 GET /api/notes/:id 接口，并将返回的数据填充到表单中。
用户修改内容。
点击“保存”按钮，调用 PUT /api/notes/:id 接口。
成功后，显示Toast“笔记保存成功”，并导航回笔记详情页。
5.4.3. 分类管理页 (/categories)
页面标题: “分类管理”
页面结构:
分类列表: 以列表形式展示所有分类。
空状态: 如果没有分类，显示“还没有任何分类，点击下方按钮创建。”
分类列表项UI元素:
分类名称: 显示分类的 name。
笔记数量: 在名称右侧用小号字体显示“(5)”，表示该分类下的笔记数量。
操作按钮: 在列表项最右侧，提供“编辑”（铅笔图标）和“删除”（垃圾桶图标）两个按钮。
交互流程:
页面加载时，调用 GET /api/categories 接口。
创建分类:
在页面底部有一个“创建新分类”按钮。
点击后，弹出一个对话框，包含一个输入框。
输入名称后，调用 POST /api/categories 接口。
成功后，刷新列表。
修改分类:
点击“编辑”按钮，列表项变为可编辑状态（或弹出对话框）。
修改名称后，调用 PUT /api/categories/{id} 接口。
成功后，刷新列表。
删除分类:
点击“删除”按钮，弹出一个确认对话框：“确定要删除此分类吗？请确保分类下没有笔记，否则无法删除。”
用户确认后，调用 DELETE /api/categories/{id} 接口。
成功 (HTTP 204): 刷新列表，显示Toast“分类已删除”。
失败 (HTTP 409): 显示错误提示：“删除失败，该分类下仍有笔记。”
下一步主动引导
“5.4. 笔记管理流程”已完成。这部分定义了用户创建、组织和管理自己知识库的完整流程。
请审查这部分定义。如果没问题，我们就可以继续最后一部分：“5.5. AI功能交互”。
--------------------------------
以上内容由AI生成，仅供参考和借鉴

好的，我们来完成第五章的最后一部分。这部分内容相对独立和简单，主要描述AI功能如何与用户进行交互。
第五章：前端页面与交互流程 (续)
5.5. AI功能交互
AI功能的核心交互是“生成AI总结”。这个交互发生在笔记详情/复习页 (/notes/:id)。
5.5.1. 触发生成
入口位置： 在笔记详情页的顶部栏，点击右侧的“更多”菜单图标。
菜单项：
如果该笔记没有AI总结，菜单项显示为“生成AI总结”。
如果该笔记已有AI总结，菜单项显示为“重新生成AI总结”。
确认对话框：
点击菜单项后，会弹出一个确认对话框，以防止误操作。
对话框标题：“生成AI总结”
对话框内容：“确定要为这篇笔记生成AI总结吗？这可能需要几十秒的时间。”
按钮：“取消” 和 “确定”。
5.5.2. 生成过程中的状态
触发操作： 用户在确认对话框中点击“确定”。
UI反馈：
对话框关闭。
“AI快速回顾”模块的内容被替换为一个加载动画（如一个思考中的AI图标和旋转的进度环）。
加载动画下方显示提示文字：“AI正在深度分析中，请稍候...”。
顶部的“更多”菜单按钮在生成过程中应被禁用，以防止重复提交。
5.5.3. 生成成功后的状态
API响应： POST /api/ai/summarize 接口返回 200 OK。
UI更新：
加载动画消失。
“AI快速回顾”模块展开，并使用API返回的 summaryText 渲染内容（支持Markdown）。
模块标题旁边可以显示一个绿色的“已更新”小标签，几秒后自动消失。
屏幕底部弹出一条成功的Toast提示：“AI总结已成功生成！”。
“更多”菜单按钮恢复可用状态。
5.5.4. 生成失败后的状态
API响应： POST /api/ai/summarize 接口返回错误码（如 400, 503）。
UI更新：
加载动画消失。
“AI快速回顾”模块显示一条明确的错误信息，并根据错误类型给出提示：
内容为空 (400): “无法生成总结：笔记内容为空。”
服务不可用 (503): “生成失败：AI服务暂时不可用，请稍后再试。”
屏幕底部弹出一条错误的Toast提示，内容与模块内显示的错误信息一致。
“更多”菜单按钮恢复可用状态，允许用户在问题解决后再次尝试。
第五章总结
至此，第五章“前端页面与交互流程”已全部完成。
我们详细定义了：
应用的所有页面结构。
从启动、登录到核心复习、笔记管理和AI功能的完整用户旅程。
每个页面的UI元素、布局和交互细节。
各种状态（加载、成功、失败、空状态）下的用户反馈。
这份文档现在为前端开发提供了清晰的、可执行的蓝图。
下一步主动引导
《V1.0 产品设计文档》的所有核心章节（1-5章）已经全部填充完毕！
你现在拥有了一份完整、详尽、逻辑严谨的产品设计文档，足以指导AI（如Copilot）或开发团队完成整个V1.0版本的开发。
接下来你希望做什么？
对文档进行最终审查和微调？
开始基于这份文档生成开发任务（如User Stories或Ticket）？
讨论其他方面，如部署、测试计划等？
--------------------------------
以上内容由AI生成，仅供参考和借鉴